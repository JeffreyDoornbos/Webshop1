/**
* DevExpress Dashboard (_entry-editor-model.js)
* Version:  22.2.4
* Build date: Jan 24, 2023
* Copyright (c) 2012 - 2023 Developer Express Inc. ALL RIGHTS RESERVED
* License: https://www.devexpress.com/Support/EULAs/universal.xml
*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntryEditorViewModel = void 0;
const validation_engine_1 = require("devextreme/ui/validation_engine");
const ko = require("knockout");
const _default_1 = require("../../../data/localization/_default");
const _jquery_helpers_1 = require("../../../data/_jquery-helpers");
const color_1 = require("../../../model/color");
const _item_filter_items_provider_1 = require("../../filtering/_item-filter-items-provider");
const _color_scheme_entry_creator_1 = require("./_color-scheme-entry-creator");
class EntryEditorViewModel {
    constructor(colorPalette) {
        this.colorPalette = colorPalette;
        this.editEntry = (dataSourceBrowser, entry, colorByMeasures, availableMeasures, updateEntry, isAutoGenerated) => {
            this.invalidate();
            this.isAutogenerated(isAutoGenerated);
            this.updateEntry = updateEntry;
            this.hasMeasures(colorByMeasures);
            this.availableMeasures(availableMeasures);
            this.entryToEdit(entry.clone());
            this.subscribeObservables();
            if (colorByMeasures) {
                this.measuresValidationRules = [{
                        type: 'custom',
                        validationCallback: () => {
                            return this.measureKeys().length > 0;
                        },
                        message: _default_1.getLocalizationById('DashboardWebStringId.Colorization.ValidationSelectMeasure')
                    }];
            }
            var dimensionEditors = [];
            var promises = [];
            this.dimensionKeys().forEach(key => {
                promises.push(dataSourceBrowser
                    .findDataField(entry.definition.dataSource, entry.definition.dataMember, key.definition.dataMember())
                    .done(field => {
                    var type = field && _item_filter_items_provider_1.getRealDimensionType(key.definition, field) || 'Unknown';
                    dimensionEditors.push({
                        dimensionKey: key,
                        valueType: type
                    });
                }));
            });
            _jquery_helpers_1.jqueryWhenArray(promises).done((fields) => {
                this.dimensionEditors(dimensionEditors);
                this.visible(true);
            });
        };
        this.close = () => {
            this.visible(false);
            this.invalidate();
        };
        this.validate = () => {
            var validationGroup = validation_engine_1.default.getGroupConfig(this._validationGroupName);
            if (!!validationGroup && validationGroup.validate().isValid) {
                this.dimensionKeys().forEach((key, index) => this.entryToEdit().dimensionKeys()[index].value.value(key.value.value()));
                this.entryToEdit().measureKeys(this.measureKeys().map(key => _color_scheme_entry_creator_1.ColorSchemeEntryCreator.createMeasureDefinitionCopy(key)));
                this.entryToEdit().paletteIndex(null);
                this.entryToEdit().color(color_1.Color.fromRgbaString(this.color()));
                this.updateEntry(this.entryToEdit());
            }
        };
        this.invalidate = () => {
            this._subscriptions.forEach(s => s.dispose());
            this._subscriptions = [];
            this.entryToEdit(null);
            this.isAutogenerated(false);
            this.measuresValidationRules = [];
            this.dimensionKeys([]);
            this.measureKeys([]);
        };
        this.visible = ko.observable(false);
        this.entryToEdit = ko.observable();
        this.isAutogenerated = ko.observable(false);
        this.hasMeasures = ko.observable();
        this.availableMeasures = ko.observableArray();
        this.measuresValidationRules = [];
        this.dimensionEditors = ko.observableArray();
        this.dimensionKeys = ko.observableArray();
        this.measureKeys = ko.observableArray();
        this.selectedMeasuresIds = ko.computed({
            read: () => {
                return this.measureKeys().map(md => md._id);
            },
            write: (selectedIds) => {
                this.measureKeys(this.availableMeasures().filter(md => selectedIds.some(id => id === md._id)));
            }
        });
        this.color = ko.observable();
        this._subscriptions = [];
        this._validationGroupName = 'newEntry';
    }
    subscribeObservables() {
        this.entryToEdit().dimensionKeys().forEach(key => this.dimensionKeys.push(_color_scheme_entry_creator_1.ColorSchemeEntryCreator.createDimensionKey(key.definition.dataMember(), key.definition.dateTimeGroupInterval(), key.value.type(), key.value.value())));
        this.measureKeys(this.entryToEdit().measureKeys().map(key => _color_scheme_entry_creator_1.ColorSchemeEntryCreator.createMeasureDefinitionCopy(key)));
        let computedColor = this.entryToEdit().paletteIndex() === null ? this.entryToEdit().color() : this.colorPalette()[this.entryToEdit().paletteIndex()];
        this.color(computedColor ? computedColor.toHex() : '');
        this.dimensionKeys().forEach(key => {
            this._subscriptions.push(key.value.value.subscribe(this.validate));
        });
        this._subscriptions.push(this.measureKeys.subscribe(this.validate));
        this._subscriptions.push(this.color.subscribe(this.validate));
    }
}
exports.EntryEditorViewModel = EntryEditorViewModel;

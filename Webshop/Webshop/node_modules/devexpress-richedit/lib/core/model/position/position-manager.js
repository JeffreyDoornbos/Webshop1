"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PositionManager = void 0;
var common_1 = require("@devexpress/utils/lib/utils/common");
var search_1 = require("@devexpress/utils/lib/utils/search");
var position_1 = require("./position");
var PositionManager = (function () {
    function PositionManager() {
        this.notLoadedPicturePositions = [];
        this.positions = [];
    }
    PositionManager.prototype.registerSpecRunPosition = function (position) {
        this.specRunPosition = new position_1.Position(position);
        return this.specRunPosition;
    };
    PositionManager.prototype.unregisterSpecRunPosition = function () {
        this.specRunPosition = null;
    };
    PositionManager.prototype.registerNotLoadedPicturePosition = function (position) {
        return this.registerPositionCore(position, this.notLoadedPicturePositions);
    };
    PositionManager.prototype.registerPosition = function (position) {
        return this.registerPositionCore(position, this.positions);
    };
    PositionManager.prototype.registerPositionCore = function (position, collection) {
        var index = search_1.SearchUtils.binaryIndexOf(collection, function (p) { return p.value - position; });
        if (index >= 0) {
            var findedPosition = collection[index];
            findedPosition.incRefCount();
            return findedPosition;
        }
        var indexWhereInsert = ~index;
        var newPosition = new position_1.Position(position);
        newPosition.incRefCount();
        collection.splice(indexWhereInsert, 0, newPosition);
        return newPosition;
    };
    PositionManager.prototype.unregisterPosition = function (position) {
        this.unregisterPositionCore(position, this.positions);
    };
    PositionManager.prototype.unregisterNotLoadedPicturePosition = function (position) {
        this.unregisterPositionCore(position, this.notLoadedPicturePositions);
    };
    PositionManager.prototype.unregisterPositionCore = function (position, collection) {
        var exactIndex = this.findPosition(position, collection);
        if (exactIndex != null) {
            var findedPosition = collection[exactIndex];
            findedPosition.decRefCount();
            if (!findedPosition.hasReference())
                collection.splice(exactIndex, 1);
        }
        else
            throw new Error("PositionManager unregisterPosition: unregister nonexisted Position");
    };
    PositionManager.prototype.findPosition = function (position, collection) {
        var index = search_1.SearchUtils.binaryIndexOf(collection, function (p) { return p.value - position.value; });
        if (index >= 0) {
            var exactIndex;
            for (exactIndex = index; exactIndex >= 0 && collection[exactIndex].value == position.value; exactIndex--) {
                if (collection[exactIndex] == position)
                    return exactIndex;
            }
            var positionsLength = collection.length;
            for (exactIndex = index + 1; exactIndex < positionsLength && collection[exactIndex].value == position.value; exactIndex++) {
                if (collection[exactIndex] == position)
                    return exactIndex;
            }
        }
        return null;
    };
    PositionManager.prototype.reset = function () {
        this.positions = [];
        this.notLoadedPicturePositions = [];
    };
    PositionManager.prototype.advance = function (position, delta, correction) {
        if (correction === void 0) { correction = 0; }
        if (common_1.isDefined(this.specRunPosition) && this.specRunPosition.value >= position)
            this.specRunPosition.value += delta;
        this.advanceCore(position + correction, this.positions, delta);
        this.advanceCore(position, this.notLoadedPicturePositions, delta);
    };
    PositionManager.prototype.advanceCore = function (position, collection, delta) {
        var index = search_1.SearchUtils.binaryIndexOf(collection, function (p) { return p.value - position; });
        var advanceIndex = index >= 0 ? index : ~index;
        var positionsLength = collection.length;
        if (advanceIndex >= positionsLength)
            return;
        if (index >= 0)
            advanceIndex = this.correctPositionIndex(position, collection, delta, advanceIndex);
        var i;
        for (i = advanceIndex; i < positionsLength; i++)
            collection[i].value += delta;
        if (delta < 0 && advanceIndex < positionsLength && advanceIndex >= 0) {
            for (i = advanceIndex; i < positionsLength && collection[i].value < position; i++)
                collection[i].value = position;
        }
    };
    PositionManager.prototype.correctPositionIndex = function (position, collection, delta, corrIndex) {
        if (delta < 0) {
            while (corrIndex < collection.length && collection[corrIndex].value == position)
                corrIndex++;
        }
        else {
            while (corrIndex > 0 && collection[corrIndex - 1].value == collection[corrIndex].value)
                corrIndex--;
        }
        return corrIndex;
    };
    return PositionManager;
}());
exports.PositionManager = PositionManager;
